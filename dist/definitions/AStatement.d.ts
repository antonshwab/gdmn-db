import { AResultSet, CursorType } from "./AResultSet";
import { ATransaction } from "./ATransaction";
import { Result } from "./fb/Result";
import { IBaseExecuteOptions, TExecutor } from "./types";
export interface INamedParams {
    [paramName: string]: any;
}
export interface IExecuteQueryOptions<R> extends IBaseExecuteOptions<AResultSet, R> {
    statement: AStatement;
    params?: any[] | INamedParams;
    cursorType?: CursorType;
}
/**
 * An object that represents a precompiled SQL statement.
 * A SQL statement is precompiled and stored in a Statement object.
 * This object can then be used absolute efficiently execute this statement multiple times.
 */
export declare abstract class AStatement {
    private readonly _transaction;
    private readonly _sql;
    protected constructor(transaction: ATransaction, sql: string);
    readonly transaction: ATransaction;
    readonly sql: string;
    abstract readonly disposed: boolean;
    static executeSelf<R>(selfReceiver: TExecutor<null, AStatement>, callback: TExecutor<AStatement, R>): Promise<R>;
    static executeQueryResultSet<R>({ statement, callback, cursorType, params }: IExecuteQueryOptions<R>): Promise<R>;
    /**
     * Executes the SQL query in this Statement object and returns
     * the ResultSet object generated by the query.
     *
     * @param {any[] | INamedParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     * @param {CursorType} type
     * @returns {Promise<AResultSet>}
     * a ResultSet object that contains the data produced by the given query;
     * never null
     */
    abstract executeQuery(params?: any[] | INamedParams, type?: CursorType): Promise<AResultSet>;
    /**
     * Executes the SQL query in this Statement object and returns the result array.
     *
     * @param {any[] | INamedParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     * @returns {Promise<Result>}
     * a result object;
     * never null
     */
    abstract executeReturning(params?: any[] | INamedParams): Promise<Result>;
    /**
     * Executes the SQL query in this Statement object.
     *
     * @param {any[] | INamedParams} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     */
    abstract execute(params?: any[] | INamedParams): Promise<void>;
    /**  Releases this Statement object's database and resources */
    abstract dispose(): Promise<void>;
}
