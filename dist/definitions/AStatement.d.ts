import { AResultSet, TResultSet } from "./AResultSet";
import { INamedParams } from "./ATransaction";
import { TExecutor } from "./types";
/**
 * Simplified type of {@link AStatement}
 */
export declare type TStatement = AStatement<TResultSet>;
/**
 * An object that represents a precompiled SQL statement.
 * A SQL statement is precompiled and stored in a Statement object.
 * This object can then be used to efficiently execute this statement multiple times.
 */
export declare abstract class AStatement<RS extends AResultSet> {
    static executeFromParent<R>(sourceCallback: TExecutor<null, TStatement>, resultCallback: TExecutor<TStatement, R>): Promise<R>;
    /**
     * Example:
     * <pre>
     * const result = await AStatement.executeResultSet(statement, async (resultSet) => {
     *      return await resultSet.getArrays();
     * })}
     * </pre>
     */
    static executeResultSet<R>(statement: TStatement, callback: TExecutor<TResultSet, R>): Promise<R>;
    /**
     * Example:
     * <pre>
     * const result = await AStatement.executeResultSet(statement, [param1, param2], async (resultSet) => {
     *      return await resultSet.getArrays();
     * })}
     * </pre>
     */
    static executeResultSet<R>(statement: TStatement, params: any[] | INamedParams, callback?: TExecutor<TResultSet, R>): Promise<R>;
    /**
     * Executes the SQL query in this Statement object and returns
     * the ResultSet object generated by the query.
     *
     * @param {any[] | INamedParams | null} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     * @returns {Promise<RS extends AResultSet>}
     * a ResultSet object that contains the data produced by the given query;
     * never null
     */
    abstract executeQuery(params?: any[] | INamedParams): Promise<RS>;
    /**
     * Executes the SQL query in this Statement object.
     *
     * @param {any[] | INamedParams | null} params
     * array of parameters or object containing placeholders as keys and parameters as values; optional
     */
    abstract execute(params?: null | any[] | INamedParams): Promise<void>;
    /**  Releases this Statement object's database and resources */
    abstract dispose(): Promise<void>;
}
